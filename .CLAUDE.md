# Athletix - Claude Code Project Guide

This document contains architectural principles, conventions, and guidelines for the Athletix project. Claude Code will reference this when working on the codebase.

---

## Core Architectural Principles

### 1. Backend-First Architecture
**All business logic, data manipulation, and filtering MUST happen in the backend.**

- ‚ùå **Never** perform data filtering, sorting, or business logic in frontend/UI components
- ‚ùå **Never** use in-memory filtering after fetching data from the database
- ‚úÖ **Always** implement data logic in API endpoints or server-side functions
- ‚úÖ **Always** use database queries with proper WHERE clauses instead of in-memory filtering
- ‚úÖ Frontend components should ONLY handle presentation and user interactions

**Reasoning:**
- Mobile/desktop apps need access to the same logic via APIs
- Performance: filtering at database level is more efficient
- Consistency: same logic used across all platforms
- Maintainability: single source of truth for business rules

**Example:**
```typescript
// ‚ùå BAD - Filtering in frontend
const entities = await prisma.entity.findMany({ where: { type: 'player' } });
const filtered = entities.filter(e => e.metadata.locationSlug === location);

// ‚úÖ GOOD - Filtering in backend
const entities = await prisma.entity.findMany({
  where: {
    type: 'player',
    metadata: { path: '$.locationSlug', equals: location }
  }
});
```

### 2. API-First Design
- All database operations should be accessible via REST API endpoints
- Server components CAN share database access functions with APIs (via `lib/data-access.ts`)
- API endpoints must be protected with authentication and rate limiting where appropriate
- All mutations must track `userId` and verify ownership

### 3. Shared Data Access Layer
- Central location: `lib/data-access.ts`
- Contains all database query functions
- Used by both API routes and server components
- Includes ownership verification for mutations

---

## Project Structure

### Key Files & Directories

```
/app
  /api                  # REST API endpoints
  /[type]               # Dynamic routes for entity types
  /components           # React components (presentation only)
/lib
  /data-access.ts       # Shared database operations (THE KEY FILE)
  /api-auth.ts          # Authentication middleware
  /api-helpers.ts       # API response utilities
  /authorization.ts     # Permission checking
  /config.ts            # Configuration (rate limits, API settings)
  /entity-utils.ts      # Entity type utilities
  /rate-limit.ts        # Rate limiting implementation
  /validation.ts        # Zod schemas for validation
/docs
  /_TODO                # Project planning and refactoring docs
```

---

## Technology Stack

- **Framework:** Next.js 16 (App Router) + React 19
- **Database:** MySQL with Prisma ORM
- **Authentication:** better-auth (JWT-based)
- **Validation:** Zod
- **Styling:** Tailwind CSS
- **Language:** TypeScript

---

## Coding Conventions

### TypeScript
- Use strict typing whenever possible
- Avoid `any` except when dealing with Prisma JSON fields or complex type compatibility issues
- Use type imports: `import type { Foo } from './bar'`

### Imports
- Prisma Client: Always import from `./lib/generated/prisma-client`
  ```typescript
  import { User } from './lib/generated/prisma-client';
  import type { Prisma } from './lib/generated/prisma-client';
  ```

### Database Operations
- Always use functions from `lib/data-access.ts`
- Never make direct Prisma calls in components or pages
- If a function doesn't exist, add it to `data-access.ts`

### API Endpoints
**Structure:**
```typescript
import { NextRequest } from 'next/server';
import { requireAuth } from '@/lib/api-auth';
import { checkRateLimit } from '@/lib/rate-limit';
import { successResponse, errorResponse, handleError } from '@/lib/api-helpers';
import { getEntityBySlug } from '@/lib/data-access';

export async function GET(request: NextRequest) {
  try {
    // 1. Authentication (if required)
    const authResult = await requireAuth(request);
    if (!authResult.success) {
      return errorResponse(authResult.error, authResult.status);
    }

    // 2. Rate limiting
    const rateLimit = checkRateLimit(request, authResult.user.id, 'general');
    if (!rateLimit.allowed) {
      return errorResponse('Rate limit exceeded', 429);
    }

    // 3. Validation
    // ... validate inputs with Zod

    // 4. Business logic (via data-access functions)
    const data = await getEntityBySlug('player', 'john-doe');

    // 5. Response
    return successResponse(data);
  } catch (error) {
    return handleError(error);
  }
}
```

### Error Handling
- Use try/catch in all async functions
- Log errors with `console.error()`
- Return user-friendly error messages (never leak sensitive info)
- Use `handleError()` helper in API routes

---

## Security Requirements

### Authentication & Authorization
- Protect all mutation endpoints (POST, PUT, DELETE) with `requireAuth()`
- Verify resource ownership before updates/deletes
- Track `userId` on all create operations
- Use `optionalAuth()` for endpoints that work with or without auth

### Rate Limiting
- Apply rate limiting to all public API endpoints
- Different limits for authenticated vs. unauthenticated users
- Configure limits in `lib/config.ts`

### Input Validation
- Validate all API inputs with Zod schemas
- Sanitize user inputs
- Never trust client-side data

---

## Performance Guidelines

### Database Queries
- Use Prisma's `select` to fetch only needed fields
- Use `include` judiciously (avoid deeply nested includes)
- Apply filters at database level (WHERE clauses, not in-memory filtering)
- Use pagination for list endpoints
- Add database indexes for commonly filtered fields

### Caching
- Use Next.js ISR (Incremental Static Regeneration) where appropriate
- Cache sports data for 1 hour
- Use `unstable_cache` for expensive operations

---

## Git Commit Conventions

When creating commits, follow these guidelines:
- Write clear, concise commit messages
- Focus on the "why" rather than the "what"
- End commits with:
  ```
  ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

  Co-Authored-By: Claude <noreply@anthropic.com>
  ```

---

## Testing Strategy

### When Refactoring
1. Run `yarn build` to check for TypeScript errors
2. Test affected endpoints manually
3. Verify server components render correctly

### Before Deployment
- Test all API endpoints
- Test authentication flows
- Verify rate limiting works
- Check ownership verification on mutations

---

## Documentation Requirements

### All Major Features Must Be Documented
**Every significant feature or system must be documented in the `/docs/` folder.**

- ‚úÖ **Always** create clear, understandable documentation for new features
- ‚úÖ **Always** update existing docs when modifying features
- ‚úÖ **Always** write documentation that a new developer could understand
- ‚ùå **Never** leave major features undocumented

**What to Document:**
- New API endpoints and their usage
- Database schema changes
- Authentication/authorization flows
- Complex business logic
- Integration patterns
- Configuration options

**Documentation Standards:**
- Use Markdown format (`.md` files)
- Include code examples where applicable
- Explain the "why" behind architectural decisions
- Keep documentation up-to-date with code changes
- Use clear headings and structure
- Include diagrams for complex flows (if helpful)

**Example Structure:**
```
/docs
  /features
    /authentication.md     # How auth works
    /rate-limiting.md      # Rate limiting system
    /entity-hierarchy.md   # Entity relationships
  /api
    /endpoints.md          # API endpoint reference
  /_TODO
    /FEATURE_NAME.md       # Planning docs for in-progress features
```

---

## Development Workflow

### Making Changes
1. Read existing code to understand current implementation
2. Plan changes (use TodoWrite tool for complex tasks)
3. Implement changes following architectural principles
4. Test with `yarn build`
5. **Document the feature in `/docs/`** (if it's a major addition)
6. Update existing documentation if modified

### Refactoring Guidelines
- Never make UI-side filtering "shortcuts" - always refactor to backend
- When moving logic from frontend to backend:
  1. Create/update function in `lib/data-access.ts`
  2. Add/update API endpoint if needed
  3. Update frontend to use the new backend function
  4. **Update documentation** to reflect changes
  5. Test thoroughly

---

## Common Patterns

### Hierarchical Data Queries
```typescript
// Traverse parent hierarchy (e.g., team ‚Üí league ‚Üí sport)
const team = await prisma.entity.findUnique({
  where: { slug: 'team-slug' },
  include: {
    parent: {
      include: {
        parent: true // sport
      }
    }
  }
});
```

### Metadata Queries (JSON fields)
```typescript
// Filter by JSON metadata field
const entities = await prisma.entity.findMany({
  where: {
    metadata: {
      path: '$.locationSlug',
      equals: 'california'
    }
  }
});
```

### Pagination
```typescript
const { page, limit } = getPaginationParams(searchParams);
const skip = (page - 1) * limit;

const entities = await prisma.entity.findMany({
  skip,
  take: limit,
});
```

---

## Notes for Claude Code

- **Priority:** Always follow the "Backend-First Architecture" principle
- **When in doubt:** Ask the user for clarification before implementing frontend logic
- **Refactoring:** If you find frontend logic that should be in the backend, proactively suggest moving it
- **Documentation:** Keep this file updated when architectural decisions are made

---

## Future Enhancements

### Planned Improvements
- Migrate rate limiting from in-memory to Redis (for horizontal scaling)
- Add comprehensive test suite (unit, integration, E2E)
- Implement audit logging for sensitive operations
- Add database indexes based on query patterns
- GraphQL API layer (if needed)

### Under Consideration
- Real-time features with WebSockets
- Advanced analytics dashboard
- Microservices architecture (if scaling requires it)

---

## Resources

- **API-First Architecture Reference:** `/docs/API_FIRST_ARCHITECTURE.md` (Complete backend filtering implementation)
- **Entity Documentation:** `/docs/ENTITIES.md`
- **Next.js Docs:** https://nextjs.org/docs
- **Prisma Docs:** https://www.prisma.io/docs
- **better-auth Docs:** https://www.better-auth.com/docs
- **Zod Docs:** https://zod.dev

---

*Last Updated: 2025-10-30*
*This document should be updated whenever significant architectural decisions are made.*
